diff --git a/src/gstvosk.c b/src/gstvosk.c
index aa4a91a..b38cab9 100644
--- a/src/gstvosk.c
+++ b/src/gstvosk.c
@@ -181,19 +181,6 @@ gst_vosk_finalize (GObject *object)
   GST_DEBUG_OBJECT (vosk, "finalizing.");
 }
 
-static void
-gst_vosk_set_num_alternatives(GstVosk *vosk)
-{
-  GST_VOSK_LOCK(vosk);
-
-  if (vosk->recognizer)
-    vosk_recognizer_set_max_alternatives (vosk->recognizer, vosk->alternatives);
-  else
-    GST_LOG_OBJECT (vosk, "No recognizer to set num alternatives.");
-
-  GST_VOSK_UNLOCK(vosk);
-}
-
 static void
 gst_vosk_class_init (GstVoskClass * klass)
 {
@@ -391,9 +378,9 @@ end:
   GST_INFO_OBJECT(vosk, "final results");
 
   if (!json_txt || !strcmp(json_txt, VOSK_EMPTY_TEXT_RESULT))
-    return json_txt;
+    return NULL;
 
-  return NULL;
+  return json_txt;
 }
 
 static void
@@ -415,6 +402,10 @@ gst_vosk_reset (GstVosk *vosk)
     vosk->prev_partial = NULL;
   }
 
+  if (vosk->last_result) {
+    g_free(vosk->last_result);
+    vosk->last_result=NULL;
+  }
   vosk->rate=0.0;
 }
 
@@ -525,12 +516,20 @@ gst_vosk_set_property (GObject * object, guint prop_id,
     }
 
     case PROP_ALTERNATIVES:
-      if (vosk->alternatives == g_value_get_int (value))
-        return;
+    {
+      int alternatives=g_value_get_int (value);
+
+      GST_VOSK_LOCK(vosk);
 
-      vosk->alternatives = g_value_get_int(value);
-      gst_vosk_set_num_alternatives (vosk);
+      if (alternatives!=vosk->alternatives) {
+        vosk->alternatives=alternatives;
+        if (vosk->recognizer)
+          vosk->updates|=GST_VOSK_UPDATE_ALTERNATIVES;
+      }
+
+      GST_VOSK_UNLOCK(vosk);
       break;
+    }
 
     case PROP_PARTIAL_RESULTS:
       vosk->partial_time_interval=g_value_get_int64(value) * GST_MSECOND;
@@ -559,17 +558,19 @@ gst_vosk_get_property (GObject *object,
       g_value_set_int(prop_value, vosk->alternatives);
       break;
 
-    /* FIXME: This should a function (+ GObject Introspection) */
     case PROP_RESULT:
-      {
-        const gchar *json_txt = NULL;
-
-        /* Note : we are certain that json_txt is valid while we have the lock */
-        GST_VOSK_LOCK(vosk);
-        json_txt = gst_vosk_final_result(vosk);
-        g_value_set_string (prop_value, json_txt);
-        GST_VOSK_UNLOCK(vosk);
+      /* Note : we are certain that json_txt is valid while we have the lock */
+      GST_VOSK_LOCK(vosk);
+
+      if (vosk->recognizer) {
+        vosk->updates|=GST_VOSK_UPDATE_RESULT;
+        g_cond_wait(&vosk->updates_done, &vosk->RecMut);
+        g_print("keeeeeeeeee %s\n", vosk->last_result);
+        g_value_take_string (prop_value, vosk->last_result);
+        vosk->last_result=NULL;
       }
+
+      GST_VOSK_UNLOCK(vosk);
       break;
 
     case PROP_PARTIAL_RESULTS:
@@ -586,10 +587,6 @@ static gboolean
 gst_vosk_set_caps (GstVosk *vosk, GstCaps *caps)
 {
   GstStructure *caps_struct;
-  const gchar *json_txt;
-  gboolean success;
-  GstCaps *outcaps;
-  gchar *caps_str;
   int rate = 0;
 
   caps_struct = gst_caps_get_structure (caps, 0);
@@ -600,60 +597,17 @@ gst_vosk_set_caps (GstVosk *vosk, GstCaps *caps)
 
   GST_VOSK_LOCK(vosk);
 
-  if (vosk->recognizer) {
-    if (G_UNLIKELY((gfloat) rate == vosk->rate)) {
-      GST_INFO_OBJECT (vosk, "rate has not changed; keeping current recognizer");
-      goto end;
-    }
-
-    GST_INFO_OBJECT (vosk, "rate has changed; updating recognizer.");
-
-    /* Send what we have recognized so far */
-    json_txt = gst_vosk_final_result (vosk);
-    gst_vosk_message_new (vosk, json_txt);
-
-    vosk_recognizer_free (vosk->recognizer);
+  /* Note: when we hold the lock we cannot use the recognizer but we can check
+   * its existence safely, since it's created with this lock. */
+  if (rate != vosk->rate) {
+    vosk->rate = rate;
+    if (vosk->recognizer)
+      vosk->updates|=GST_VOSK_UPDATE_RATE;
   }
-  else if (!vosk->model) {
-    GST_INFO_OBJECT (vosk, "model not yet loaded");
-    goto end;
-  }
-  else
-    GST_INFO_OBJECT (vosk, "no recognizer yet available to set rate ; creating one");
-
-  vosk->recognizer = gst_vosk_recognizer_new (vosk, vosk->model, rate);
 
-end:
   GST_VOSK_UNLOCK(vosk);
 
-  caps_str = g_strdup_printf ("audio/x-raw,"
-                              "format=S16LE,"
-                              "rate=%i,"
-                              "channels=1", rate);
-  outcaps = gst_caps_from_string (caps_str);
-  g_free (caps_str);
-
-  success = gst_pad_set_caps (vosk->srcpad, outcaps);
-  gst_caps_unref (outcaps);
-
-  return success;
-}
-
-static void
-gst_vosk_flush(GstVosk *vosk)
-{
-  GST_INFO_OBJECT (vosk, "flushing");
-
-  GST_VOSK_LOCK(vosk);
-
-  if (vosk->recognizer) {
-    vosk_recognizer_reset(vosk->recognizer);
-    vosk->processed_size = 0;
-  }
-  else
-    GST_DEBUG_OBJECT (vosk, "no recognizer to flush");
-
-  GST_VOSK_UNLOCK(vosk);
+  return gst_pad_set_caps (vosk->srcpad, caps);
 }
 
 static gboolean
@@ -678,7 +632,10 @@ gst_vosk_sink_event (GstPad *pad,
     }
 
     case GST_EVENT_FLUSH_START:
-      gst_vosk_flush(vosk);
+      GST_VOSK_LOCK(vosk);
+      if (vosk->recognizer)
+        vosk->updates|=GST_VOSK_UPDATE_FLUSH;
+      GST_VOSK_UNLOCK(vosk);
       break;
 
     case GST_EVENT_EOS:
@@ -824,6 +781,46 @@ gst_vosk_handle_buffer(GstVosk *vosk, GstBuffer *buf)
   }
 }
 
+static void
+gst_vosk_update(GstVosk *vosk)
+{
+  GST_VOSK_LOCK(vosk);
+
+  if (vosk->updates & GST_VOSK_UPDATE_ALTERNATIVES)
+    vosk_recognizer_set_max_alternatives(vosk->recognizer, vosk->alternatives);
+
+  if (vosk->updates & GST_VOSK_UPDATE_RESULT) {
+    const gchar *json_txt = gst_vosk_final_result(vosk);
+
+    if(vosk->last_result)
+      g_free(vosk->last_result);
+
+    vosk->last_result=g_strdup(json_txt);
+    g_print("kdkd %s\n", vosk->last_result);
+  }
+
+  if (vosk->updates & GST_VOSK_UPDATE_RATE) {
+    const char *json_txt;
+
+    /* Send what we have recognized so far */
+    json_txt = gst_vosk_final_result (vosk);
+    gst_vosk_message_new (vosk, json_txt);
+
+    vosk_recognizer_free(vosk->recognizer);
+    vosk->recognizer = gst_vosk_recognizer_new (vosk, vosk->model, vosk->rate);
+  }
+
+  if (vosk->updates & GST_VOSK_UPDATE_FLUSH)
+    vosk_recognizer_reset(vosk->recognizer);
+
+  vosk->updates=GST_VOSK_UPDATE_NONE;
+  g_cond_broadcast(&vosk->updates_done);
+
+  GST_VOSK_UNLOCK(vosk);
+
+  GST_INFO_OBJECT (vosk, "updates completed.");
+}
+
 typedef struct {
   gchar *path;
   GCancellable *cancellable;
@@ -945,11 +942,11 @@ gst_vosk_chain (GstPad *sinkpad,
 
   GST_LOG_OBJECT (vosk, "data received");
 
-  GST_VOSK_LOCK(vosk);
-
   if (G_UNLIKELY(!vosk->recognizer)) {
     GstVoskThreadData *thread_data;
 
+    GST_VOSK_LOCK(vosk);
+
     /* Start loading a new model */
     vosk->current_operation=g_cancellable_new();
 
@@ -962,16 +959,18 @@ gst_vosk_chain (GstPad *sinkpad,
 
     /* Block until the thread finishes or until it is cancelled */
     g_cond_wait(&vosk->wake_stream, &vosk->RecMut);
+
+    GST_VOSK_UNLOCK(vosk);
+
     GST_INFO_OBJECT (vosk, "woken up, model should be ready");
-    if (!vosk->model || !vosk->recognizer) {
-      GST_VOSK_UNLOCK(vosk);
+    if (!vosk->model || !vosk->recognizer)
       return GST_FLOW_OK;
-    }
   }
 
-  gst_vosk_handle_buffer(vosk, buf);
+  if (G_UNLIKELY(vosk->updates!=GST_VOSK_UPDATE_NONE))
+    gst_vosk_update(vosk);
 
-  GST_VOSK_UNLOCK(vosk);
+  gst_vosk_handle_buffer(vosk, buf);
 
   GST_LOG_OBJECT (vosk, "chaining data");
   gst_buffer_ref(buf);
diff --git a/src/gstvosk.h b/src/gstvosk.h
index accd674..0e08cf1 100644
--- a/src/gstvosk.h
+++ b/src/gstvosk.h
@@ -27,6 +27,14 @@
 
 G_BEGIN_DECLS
 
+typedef enum {
+  GST_VOSK_UPDATE_NONE            = 0,
+  GST_VOSK_UPDATE_FLUSH           = 2,
+  GST_VOSK_UPDATE_ALTERNATIVES    = 4,
+  GST_VOSK_UPDATE_RATE            = 8,
+  GST_VOSK_UPDATE_RESULT          = 16
+} GstVoskUpdateType;
+
 #define GST_TYPE_VOSK \
   (gst_vosk_get_type())
 #define GST_VOSK(obj) \
@@ -57,6 +65,11 @@ struct _GstVosk
 
   GMutex            RecMut;
 
+  GstVoskUpdateType updates;
+  GCond             updates_done;
+
+  gchar            *last_result;
+
   /* Access to the following members should be done
    * with GST_VOSK_LOCK held */
   VoskModel        *model;
